# Ft_IRC

Subject: https://cdn.intra.42.fr/pdf/pdf/119214/en.subject.pdf

Tutorial basico: https://medium.com/@afatir.ahmedfatir/small-irc-server-ft-irc-42-network-7cee848de6f9

Documentação protocolo IRC: https://modern.ircdocs.horse/



| Function | Prototype | Description | Library |
|----------|-----------|-------------|-------------|
| socket | int socket(int domain, int type, int protocol); | The socket() function shall create an unbound socket in a communications domain, and return a file descriptor that can be used in later function calls that operate on sockets. | #include <sys/socket.h> |
| close | void close(); | Closes the file currently associated with the object, disassociating it from the stream. | <fstream> |
| setsockopt | int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len); | The setsockopt() function shall set the option specified by the option_name argument, at the protocol level specified by the level argument, to the value pointed to by the option_value argument for the socket associated with the file descriptor specified by the socket argument. | #include <sys/socket.h> |
| getsockname| int getsockname(int sockfd, struct sockaddr *restrict addr,    socklen_t *restrict addrlen); | getsockname() returns the current address to which the socket  sockfd is bound, in the buffer pointed to by addr.  The addrlen argument should be initialized to indicate the amount of space (in bytes) pointed to by addr.  On return it contains the actual size of the socket address. | #include <sys/socket.h> |
| getprotobyname | struct protoent *getprotobyname(const char *name); | The getprotobyname() function returns a protoent structure for the entry from the database that matches the protocol name name. A connection is opened to the database if necessary. | #include <netdb.h> |
| gethostbyname | struct hostent *gethostbyname(const char *name); | gethostbyname() takes a string like "www.yahoo.com", and returns a struct hostent which contains tons of information, including the IP address. (Other information is the official host name, a list of aliases, the address type, the length of the addresses, and the list of addresses--it's a general-purpose structure that's pretty easy to use for our specific purposes once you see how.) | #include <sys/socket.h> \n #include <netdb.h> |
| freeaddrinfo | void freeaddrinfo(struct addrinfo *ai); | The freeaddrinfo() function shall free one or more addrinfo structures returned by getaddrinfo(), along with any additional storage associated with those structures. If the ai_next field of the structure is not null, the entire list of structures shall be freed. The freeaddrinfo() function shall support the freeing of arbitrary sublists of an addrinfo list originally returned by getaddrinfo(). | #include <sys/socket.h> \n #include <netdb.h> |
| bind | template <class Fn, class... Args>  /* unspecified */ bind (Fn&& fn, Args&&... args); \n template <class Ret, class Fn, class... Args>  /* unspecified */ bind (Fn&& fn, Args&&... args); | Returns a function object based on fn, but with its arguments bound to args. | #include <functional> |
| connect | int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); | The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. The addrlen argument specifies the size of addr.  The format of the address in addr is determined by the address space of the socket sockfd; see socket(2) for further details. | #include <sys/socket.h> |
| listen | int listen(int sockfd, int backlog); | listen() marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connection requests using accept(2). | #include <sys/socket.h> |
| accept | int accept(int sockfd, struct sockaddr *_Nullable restrict addr, socklen_t *_Nullable restrict addrlen); | It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call. | #include <sys/socket.h> |
| htons | uint16_t htons(uint16_t hostshort); | the way these functions work is that you first decide if you're converting from host (your machine's) byte order or from network byte order. If "host", the the first letter of the function you're going to call is "h". Otherwise it's "n" for "network". The middle of the function name is always "to" because you're converting from one "to" another, and the penultimate letter shows what you're converting to. The last letter is the size of the data, "s" for short, or "l" for long. | #include <netinet/in.h> |
| htonl | uint32_t htonl(uint32_t hostlong); | the way these functions work is that you first decide if you're converting from host (your machine's) byte order or from network byte order. If "host", the the first letter of the function you're going to call is "h". Otherwise it's "n" for "network". The middle of the function name is always "to" because you're converting from one "to" another, and the penultimate letter shows what you're converting to. The last letter is the size of the data, "s" for short, or "l" for long. | #include <netinet/in.h> |
| ntohs | uint16_t ntohs(uint16_t netshort); | the way these functions work is that you first decide if you're converting from host (your machine's) byte order or from network byte order. If "host", the the first letter of the function you're going to call is "h". Otherwise it's "n" for "network". The middle of the function name is always "to" because you're converting from one "to" another, and the penultimate letter shows what you're converting to. The last letter is the size of the data, "s" for short, or "l" for long. | #include <netinet/in.h> |
| ntohl | uint32_t ntohl(uint32_t netlong); | the way these functions work is that you first decide if you're converting from host (your machine's) byte order or from network byte order. If "host", the the first letter of the function you're going to call is "h". Otherwise it's "n" for "network". The middle of the function name is always "to" because you're converting from one "to" another, and the penultimate letter shows what you're converting to. The last letter is the size of the data, "s" for short, or "l" for long. | #include <netinet/in.h> |
| inet_addr | in_addr_t inet_addr(const char *cp); | The inet_addr() function shall convert the string pointed to by cp, in the standard IPv4 dotted decimal notation, to an integer value suitable for use as an Internet address. | #include <arpa/inet.h> |
| inet_ntoa | char *inet_ntoa(struct in_addr in); | The inet_ntoa() function shall convert the Internet host address specified by in to a string in the Internet standard dot notation. | #include <arpa/inet.h> |
| send | ssize_t send(int socket, const void *buffer, size_t length, int flags); | The send() function shall initiate transmission of a message from the specified socket to its peer. The send() function shall send a message only when the socket is connected (including when the peer of a connectionless socket has been set via connect()). | #include <sys/socket.h> |
| recv | ssize_t recv(int s, void *buf, size_t len, int flags); | Once you have a socket up and connected, you can read incoming data from the remote side using the recv() (for TCP SOCK_STREAM sockets) and recvfrom() (for UDP SOCK_DGRAM sockets). | #include <sys/types.h> \n #include <sys/socket.h> |
| signal | sighandler_t signal(int signum, sighandler_t handler); | signal() sets the disposition of the signal signum to handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined function (a "signal handler"). |  #include <signal.h> |
| sigaction | int sigaction(int signum, const struct sigaction *_Nullable restrict act, struct sigaction *_Nullable restrict oldact); | The sigaction() system call is used to change the action taken by a process on receipt of a specific signal.  (See signal(7) for an overview of signals.) | #include <signal.h> |
| lseek | off_t lseek(int fd, off_t offset, int whence); | lseek() repositions the file offset of the open file description associated with the file descriptor fd to the argument offset according to the directive whence as follows: SEEK_SET The file offset is set to offset bytes. SEEK_CUR The file offset is set to its current location plus offset bytes. SEEK_END The file offset is set to the size of the file plus offset bytes. |  #include <unistd.h> |
| fstat | int fstat(int fd, struct stat *buf); | This functions return information about a file. No permissions are required on the file itself, but-in the case of stat() - execute (search) permission is required on all of the directories in path that lead to the file. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd. | #include <sys/types.h> \n #include <sys/stat.h> \n #include <unistd.h> |
| fcntl | int fcntl(int fd, int op, ... /* arg */ ); | fcntl() performs one of the operations described below on the open file descriptor fd. The operation is determined by op. | #include <fcntl.h> |
| poll | int poll(struct pollfd *fds, nfds_t nfds, int timeout); | poll() performs a similar task to select(2): it waits for one of a set of file descriptors to become ready to perform I/O. | #include <poll.h> |
